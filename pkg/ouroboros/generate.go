package ouroboros

import (
	"fmt"
	"os"
	"path/filepath"
	"text/template"
)

// Template constants - using the same templates as CLI
const programsHeaderTemplate = `// Code generated by ouroboros. DO NOT EDIT.
// This file is automatically generated by the ouroboros tool.

#ifndef __PROGRAMS_H
#define __PROGRAMS_H

#include <linux/bpf.h>
#include <bpf/bpf_helpers.h>

#define PROG_MAP_NAME {{.ProgramMap}}
#define PROG_MAX_ENTRIES 65535

struct {
    __uint(type, BPF_MAP_TYPE_PROG_ARRAY);
    __uint(max_entries, PROG_MAX_ENTRIES);
    __type(key, __u32);
    __type(value, __u32);
    __uint(pinning, LIBBPF_PIN_BY_NAME);
} PROG_MAP_NAME SEC(".maps");

#define __STRINGIFY(x) #x

#define JUMP_TO_PROGRAM(ctx, idx) \
    bpf_tail_call(ctx, &PROG_MAP_NAME, idx); \
    bpf_printk("Jumping to program " #idx " FAILED! Check if ouroboros is correctly generating programs.h. Falling back to XDP_PASS. Occurred @ " __FILE__ ":" __STRINGIFY(__LINE__)); \
    return XDP_PASS;


// Programs
{{range .Programs}}#define PROG_{{.Name}} {{.ID}}
{{end}}

#endif // __PROGRAMS_H
`

const gitignoreTemplate = `target/
src/_ouroboros/
*.o
*.ll
ouroboros
`

const makefileTemplate = `.PHONY: build clean load unload

build:
	ouroboros build

clean:
	ouroboros clean

load:
	sudo ouroboros load

unload:
	sudo ouroboros unload

attach:
	sudo ouroboros attach $(IFACE)

detach:
	sudo ouroboros detach $(IFACE)
`

// GenerateProgramsHeader generates the programs.h header file in src/_ouroboros/.
// This header contains #define constants for each program's ID, making it easy
// to reference programs in C code (especially for tail calls).
func (o *Ouroboros) GenerateProgramsHeader() error {
	if err := o.EnsureGlobalDirectory(); err != nil {
		return err
	}

	headerPath := filepath.Join("src/_ouroboros", "programs.h")

	// Parse template
	tmpl, err := template.New("programs.h").Funcs(template.FuncMap{
		"upper": func(s string) string {
			// Simple uppercase conversion
			result := make([]byte, len(s))
			for i := 0; i < len(s); i++ {
				if s[i] >= 'a' && s[i] <= 'z' {
					result[i] = s[i] - 32
				} else {
					result[i] = s[i]
				}
			}
			return string(result)
		},
	}).Parse(programsHeaderTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Create file
	file, err := os.Create(headerPath)
	if err != nil {
		return fmt.Errorf("failed to create %s: %w", headerPath, err)
	}
	defer file.Close()

	// Execute template with config data
	if err := tmpl.Execute(file, o.config); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}

// GenerateGitignore creates a .gitignore file for the project.
func (o *Ouroboros) GenerateGitignore() error {
	file, err := os.Create(".gitignore")
	if err != nil {
		return fmt.Errorf("failed to create .gitignore: %w", err)
	}
	defer file.Close()

	tmpl, err := template.New("gitignore").Parse(gitignoreTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	if err := tmpl.Execute(file, nil); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}

// GenerateMakefile generates a basic Makefile for building the project.
func (o *Ouroboros) GenerateMakefile() error {
	file, err := os.Create("Makefile")
	if err != nil {
		return fmt.Errorf("failed to create Makefile: %w", err)
	}
	defer file.Close()

	tmpl, err := template.New("makefile").Parse(makefileTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	if err := tmpl.Execute(file, nil); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}
